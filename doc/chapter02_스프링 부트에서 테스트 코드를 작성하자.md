## 스프링 부트에서 테스트코드를 작성하자.
### 테스트 코드 소개
- TDD와 단위 테스트는 다른 이야기이다. TDD는 테스트가 주도하는 개발로, 테스트 코드를 먼저 작성하는 것부터 시작한다.
- 레드 그린 싸이클(p.52)
  - 항상 실패하는 테스트를 먼저 작성(Red)
  - 테스트가 통과하는 프로덕션 코드를 작성(Green)
  - 테스트가 통과하면 프로덕션 코드를 리팩토링(Refactor)
- 단위테스트는 TDD의 첫 번째 단계인 기능 단위의 테스트 코드를 작성하는 것
- 단위 테스트 코드 장점
  - 개발 단계 초기에 문제를 발견하게 해준다.
  - 개발자가 추후에 리팩토링 및 라이브러리 업그레이드 등에서 기존 기능이 올바르게 작동하는지 확인 가능
  - 기능에 대한 불확실성 감소
  - 시스템에 대한 실제 문서 제공. 즉, 단위 테스트 자체가 문서로 사용 가능
- jojoldo님의 경험
  1. 코드 작성
  2. 프로그램 실행   
  3. API 테스트 도구(Postman)로 HTTP 요청
  4. 요청 결과를 로그로 찍어 눈으로 검증
  5. 결과가 다르면 다시 프로그램 중지 후 코드 수정
  - 여기서 2 ~ 5는 코드 수정마다 반복
  - 테스트 코드가 있다면, 톰캣을 내렸다가 다시 실행시키는 일을 반복할 필요가 없어져 효율성 증가
  - 개발자 눈으로 검증하지 않아도 자동 검증 가능
  - 개발자가 만든 기능 안전하게 보호 가능
  - 작동이 잘 되는 B 기능 추가 후 오픈해보니 A 기능 문제가 발견! 여기서 기존 기능이 잘 작동 되는 것을 보장해줄 수 있다.
  
### Hello Controller 테스트 코드 작성하기
- 일반적으로 패키지명은 웹 사이트 주소의 역순으로 만든다.


### 롬복 소개 및 설치하기
- build.gradle에 의존성 추가 -> compile('org.projectlombok:lombok')
- 의존성 추가 후 Gradle 탭에서 Refresh 눌러주기.
- Action 검색 (윈도우 키: Ctrl Shift A)에서 plugins 검색 후 lombok 검색 후 설치
- Annotation Processors에서 Enable annotation processing 체크
- 롬복은 프로젝트마다 설정해야 한다. 플러그인은 한 번 깔면 되지만, build.gradle에 라이브러리 추가 및 annotation processor 체크는 해주어야 한다.
- 테스트 상용 시 junit의 기본 assertThat이 아닌, assertj의 assertThat을 사용했는데, 다음과 같은 장점이 있다.
  - CoreMatchers와 달리 추가적으로 라이브러리가 필요하지 않다.
    - JUnit assertThat을 사용 시 is()와 같이 CoreMatchers 라이브러리가 필요하다.
  - 자동 완성이 좀 더 확실히 지원
    - IDE에서는 CoreMatchers와 같은 Matcher 라이브러리의 자동 완성 지원이 약하다.

## 예외 발생
- p.73 테스트 코드 수행 시 예외 발생
  - Gradle 버전 5. 버전이었는데, 이를 4.10.2로 변경하니 제대로 작동했다.

