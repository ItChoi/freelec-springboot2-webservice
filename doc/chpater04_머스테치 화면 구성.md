## 머스테치로 화면 구성하기

### 서버 템플릿 엔진과 머스테치 소개
- 템플릿 엔진이란?
  - 지정된 템플릿(jsp, view) 양식과 데이터가 합쳐져 HTML문서를 출력하는 소프트웨어
    - jsp: 서버 템플릿 엔진(명확하게는 서버 템플릿 엔진은 아니지만, View 역할만 하도록 구성할 때는 템플릿 엔진으로 사용 가능, 이 경우에는 Spring + jsp 사용)
      - 서버 템플릿 엔진: 화면 생성 시 서버에서 Java 코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달       
    - view: 클라이언트 템플릿 엔진
      - JavaScript는 브라우저 위에서 작동한다. 즉 코드 실행이 서버가 아닌 브라우저다. 
      - 서버에서 Json 혹은 Xml 형식의 데이터만 전달하고, 클라이언트에서 조립한다.
        - 최근에는 리액트나 뷰와 같은 자바스크립트 프레임워크에서 서버 사이드 렌더링을 지원할 수 있다. 간략하게, 화면 생성 방식을 서버에서 실행하는 것.
        - 스프링 부트 사용 시 자바스크립트를 서버 사이드에서 렌더링하도록 구현하는 것은 수고가 많이 필요하여 시작하는 단계에서는 조졸두님은 추천하지 않는다.
    ```javascript
    <script type="text/javascript>        
    $(document).ready(function() {
        // if문의 조건과는 관계 없이 test로그는 찍힌다.
        // 왜냐하면, 자바스크립트 작동 영역과 jsp 작동 영역이 다르기 때문인데,
        // jsp를 비롯한 서버 템플릿 엔진은 서버에서 구동된다.
        if (a == "1") {
            <%
                System.out.println("test");    
            %>
        }
    });
    </script>
    ```    

- 머스테치란?
  - 수 많은 언어를 지원하는 가장 심플한 템플릿 엔진 (jsp와 같이 HTML을 만들어주는 템플릿 엔진)
  - 서버 템플릿 엔진 / 클라이언트 템플릿 엔진 모두 사용 가능
  - 템플릿 엔진 단점
    - jsp, Velocity: 스프링 부트에서 권장하지 않는다.
    - Freemaker: 템플릿 엔진으로는 과하게 많은 기능을 지원한다. 숙련도가 낮으면 비즈니스 로직이 추가될 확률이 높다.
    - Thymeleaf: 스프링 진영에서 적극적으로 밀고 있지만, 문법이 어렵당. 
  - 머스테치 장점
    - 문법이 심플
    - 로직 코드 사용 불가로 View 역할과 서버 역할 명확하게 분리
    - 하나의 문법으로 클라이언트 / 서버 템플릿 모두 사용 가능
- 머스테치 플러그인 설치
  - 인텔리제이 커뮤니티 버전에서도 플러그인 사용 가능
  - 머스테치 문법 체크, HTML 문법 지원, 자동 완성 등 지원

### 기본 페이지 만들기
- 머스테치 스타터 의존성 추가 - build.gradle
  - compile('org.springframework.boot:spring-boot-starter-mustache')  
- 머스테치 파일의 위치는 기본적으로 src/main/resources/templates
  
  
- 꿀팁
  - index.js에서 var index = { }; 객체 안에 함수를 넣는 이유가 뭘까?
    - 브라우저의 스코프는 공용 공간이기 때문에 나중에 다른 js파일과 함수가 겹칠 경우 나중에 로딩 된것이 덮어 쓰게 되는 경우가 있다. 따라서 index.js만의 유효 범위를 만들어 사용
  - 절대 경로(/)로 바로 시작하는데, 스프링 부트는 기본적으로 src/main/resources/static에 위치한 JS, CSS, 이미지 등 정적 파일들은 URL에서 /로 설정된다.
    - 그래서 다음과 같이 위치하면 위치에 맞게 호출 가능
      1. src/main/resources/static/js/..      (http://도메인/js/..)
      2. src/main/resources/static/css/..     (http://도메인/css/..)
      3. src/main/resources/static/image/..   (http://도메인/image/..)    
- {{#post}}: posts라는 List 순회, {{변수명}}: List에서 뽑아낸 객체의 필드 사용
- 규모가 있는 플젝에서 데이터 조회는 FK의 조인, 복잡한 조건 등으로 @Entity클래스만으로 처리가 어려워 조회용 프레임워크를 추가로 사용한다.
  - 조회용 프레임워크
    - querydsl, jooq, MyBatis, 등
    - 조회는 위 3 가지 프레임워크 중 하나를 통해 조회, 수정/삭제/등록은 SpringDataJpa로 진행한다. 조졸두님 추천은 querydsl
    - QueryDsl 추천 이유
      1. 타입 안정성이 보장된다.
        - 단순한 문자열로 쿼리 생성이 아니라, 메소드를 기반으로 쿼리를 생성하기에 오타나 존재하지 않는 컬럼명 IDE에서 자동 검출 가능 (MyBatis는 지원하지 않는다.)
      2. 국내 많은 회사에서 사용 중
      3. 레퍼런스가 많다.
        - 많은 회사와 개발자들이 사용하는 만큼 자료가 많다.
        
          
  
      